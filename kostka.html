<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <!--   ***********************************************************************
     část tohoto úvodního HTML kodu byl převzat od třetí strany
   kod pouze vytváří prázdnou Babylon.js aplikaci, něco jako Hello world aplikaci
   je prevzatá ze stránek https://doc.babylonjs.com/start/chap1/first_app 
   
   prevzaty kod je rozdelen na 2 casti 
   druha cast prevzateho kodu je na samem konci souboru -->
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
      <title>Kostka</title>

      <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>  

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="algoritmy.js"></script>
      



   </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

    <script>

     var canvas = document.getElementById("renderCanvas"); 

    var engine = new BABYLON.Engine(canvas, true);
         
var createScene = function () {

 //konec prevzaté cásti
  // autor všeho odtud po konec funkce createScene: Tomáš Pribyl

    const koliz_cas_pole = [];            // úvodní promenné
    const pocet_kolizi_pole = [];
    const pocet_meshu = [];
    var max_pole = 500;
    var index_pole = 0;


    engine.enableOfflineSupport = false;

    // scéna
    var scene = new BABYLON.Scene(engine);
    
     //kamera
    var kamera = new BABYLON.ArcRotateCamera("kamera", Math.PI / 2, Math.PI / 4, 10, new BABYLON.Vector3(0, -5, 0), scene);
    scene.activeCamera = kamera;
    scene.activeCamera.attachControl(canvas, true);
    kamera.lowerRadiusLimit = 2;
    kamera.upperRadiusLimit = 10;
    kamera.wheelDeltaPercentage = 0.01;

    // svetla
    var svetlo = new BABYLON.HemisphericLight("svetlo", new BABYLON.Vector3(0, 1, 0), scene);
    svetlo.intensity = 0.6;
    svetlo.specular = BABYLON.Color3.Black();

    var svetlo2 = new BABYLON.DirectionalLight("svetlo2", new BABYLON.Vector3(0, -0.5, -1.0), scene);
    svetlo2.position = new BABYLON.Vector3(0, 5, 5);    
    
    var isLocked = false;
	// pohyb kamerou myší
	scene.onPointerDown = function (evt) 
    {
		if (!isLocked)
        {
			canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
			if (canvas.requestPointerLock)
            {
				canvas.requestPointerLock();
			}
		}
	};
	


	var pointerlockchange = function () {
		var controlEnabled = document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement || document.pointerLockElement || null;
		
		if (!controlEnabled) 
        {
			isLocked = false;
		} 
        else
        {
			isLocked = true;
		}
	};

    // reakce kláves
    var inputMap = {};
    scene.actionManager = new BABYLON.ActionManager(scene);
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
    }));
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
    }));


         // vytvorení sten kostky
        var ground = BABYLON.MeshBuilder.CreateBox("ground", {width: 12, height: 0.5, depth: 12}, scene);
        ground.rotation = new BABYLON.Vector3(0, 0, 0);        ground.rotation.x = 180 * Math.PI / 180 ;
         ground.position.y = -12;
        
        var ground1 = BABYLON.MeshBuilder.CreateBox("ground", {width: 12, height: 0.5, depth: 12}, scene);
        ground1.rotation = new BABYLON.Vector3(0, 0, 0);    
       
        
        var ground2 = BABYLON.MeshBuilder.CreateBox("ground", {width: 12, height: 0.5, depth: 12}, scene);
        ground2.rotation = new BABYLON.Vector3(0, 0, 0);   ground2.rotation.x = 90 * Math.PI / 180 ;
          ground2.position.z = 6;         ground2.position.y = -6;
        
        var ground3 = BABYLON.MeshBuilder.CreateBox("ground", {width: 12, height: 0.5, depth: 12}, scene);
        ground3.rotation = new BABYLON.Vector3(0, 0, 0);   ground3.rotation.x = -90 * Math.PI / 180 ;
           ground3.position.z = -6;         ground3.position.y = -6;
        
        var ground4 = BABYLON.MeshBuilder.CreateBox("ground", {width: 12, height: 0.5, depth: 12}, scene);
        ground4.rotation = new BABYLON.Vector3(0, 0, 0);   ground4.rotation.z = -90 * Math.PI / 180 ;
        ground4.position.x = 6;            ground4.position.y = -6;
        
        var ground5 = BABYLON.MeshBuilder.CreateBox("ground", {width: 12, height: 0.5, depth: 12}, scene);
        ground5.rotation = new BABYLON.Vector3(0, 0, 0);   ground5.rotation.z = 90 * Math.PI / 180 ;
        ground5.position.x = -6;            ground5.position.y = -6;
        
        ground.visibility = 0.2;
        ground1.visibility = 0.2;
        ground2.visibility = 0.2;
        ground3.visibility = 0.2;
        ground4.visibility = 0.2;
        ground5.visibility = 0.2;   
        
         // kapsle kterou uživatel ovládá
       var hero = new BABYLON.MeshBuilder.CreateCapsule("capsule", {radius:0.25, capSubdivisions: 6, subdivisions:6, tessellation:36, height:2, orientation:BABYLON.Vector3.Forward()});
       hero.position.x = 12;

       var herodMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
       herodMaterial.diffuseColor  = new BABYLON.Color3(1, 0, 0);
       hero.material = herodMaterial; 

        hero.visibility = 0.2;


        // kamera sleduje kapsli
        kamera.target = hero;

        // nastavení pohybu kapsle
        var heroSpeed = 0;
        var heroSpeedBackwards = 0.1;
        var heroRotationSpeed = 0.01;

        var vektor = new BABYLON.Vector3(0, 1, 0);
        var vektor1 = new BABYLON.Vector3(0, -1, 0); 
        
        // ovládání rychlosti kapsle
        //autor: Tomáš Pribyl
        //studijní materiály:[1]
        scene.onPointerObservable.add((pointerInfo) => {
		switch (pointerInfo.type) {
			case BABYLON.PointerEventTypes.POINTERWHEEL:
                if(pointerInfo.event.deltaY < 0)
                {
                    if(heroSpeed < 0.2)
                    {
                         heroSpeed = heroSpeed+0.1
                    }
                }
                else if (pointerInfo.event.deltaY > 0)
                {
                    if(heroSpeed > -0.2)
                    {
                         heroSpeed = heroSpeed - 0.1
                    }
                }
            break;
        }
    });
         let rychlosti = [Math.random() / 5];
         for (let i = 0; i < 500; i++) {
              rychlosti.push(Math.random() / 5); 
        } 
        
        let index_detekce = 0;   
        
        // smycka ktera reaguje na každy vytvoreny snimek simulace a predtim provede akci
        scene.onBeforeRenderObservable.add(() => {   
            let x = 0;

     
            //ovládání kapsle  
             //autor: Tomáš Pribyl 
             //studijní materiály:[1] 
            hero.moveWithCollisions(hero.forward.scaleInPlace(heroSpeed));     //xxxxxxxxxxxxxx
            var keydown = false;

           
            if (inputMap["a"]) {
                hero.rotate(BABYLON.Vector3.Up(), -heroRotationSpeed);
         
                keydown = true;
            }
            if (inputMap["d"]) {
                hero.rotate(BABYLON.Vector3.Up(), heroRotationSpeed);
         
                keydown = true;
            }
            if (inputMap["s"]) {
           
            hero.moveWithCollisions(hero.up.scaleInPlace(-heroSpeedBackwards));
                keydown = true;
            }
            if (inputMap["w"]) {
            
            hero.moveWithCollisions(hero.up.scaleInPlace(heroSpeedBackwards));
                keydown = true;
            }
              
             // klávesy pro pohyb koulí v kostce, pokud by se nedostatecne hýbaly 
            //autor: Tomáš Pribyl 
             //studijní materiály:[1]        
            let aaa = balls.length-1;
            let xx = 0; 
            if (inputMap["1"]) {
                balls.forEach(ball => {
                ball.moveWithCollisions(ball.right.scaleInPlace(-rychlosti[xx]));  xx = xx + 1; xx = xx % 500;
                }); 
                keydown = true;
            }
            if (inputMap["3"]) {
                balls.forEach(ball => {
                ball.moveWithCollisions(ball.right.scaleInPlace(rychlosti[xx]));  xx = xx + 1;
                });
                keydown = true;
            }
            if (inputMap["4"]) {
                balls.forEach(ball => {
                ball.moveWithCollisions(ball.forward.scaleInPlace(rychlosti[xx]));  xx = xx + 1;
                });
                keydown = true;
            }
            if (inputMap["6"]) {
                balls.forEach(ball => {
                ball.moveWithCollisions(ball.forward.scaleInPlace(-rychlosti[xx]));  xx = xx + 1;
                });
                keydown = true;
            }
            if (inputMap["5"]) {
                balls.forEach(ball => {
                ball.moveWithCollisions(ball.up.scaleInPlace(rychlosti[xx]));  xx = xx + 1;
                });
                keydown = true;
            }
            if (inputMap["2"]) {
                balls.forEach(ball => {
                ball.moveWithCollisions(ball.up.scaleInPlace(-rychlosti[xx]));  xx = xx + 1;
                });
                keydown = true;
            }
            
             // nastavení algoritmu pro detekci kolizí
             //autor: Tomáš Pribyl 
             //studijní materiály:[1] 
            if (inputMap["g"]) {
                index_detekce = 0; index_pole = 0;  console.log("Alg s vestavenou funkci");
                keydown = true;
            }
            if (inputMap["h"]) {
                index_detekce = 1; index_pole = 0;  console.log("Alg s nejvetsim rozmerem");
                keydown = true;
            }
            if (inputMap["j"]) {
                index_detekce = 2; index_pole = 0;   console.log("Alg s AABB");
                keydown = true;
            }
            if (inputMap["k"]) {
                index_detekce = 3; index_pole = 0;   console.log("Alg s FaceT a pocitadlem vzdalenosti");
                keydown = true;
            }
            if (inputMap["l"]) {
                index_detekce = 4; index_pole = 0;   console.log("Alg s OBB");
                keydown = true;
            }
            if (inputMap["p"]) {
                index_detekce = 5; index_pole = 0;   console.log("Alg s FaceT a vektory");
                keydown = true;
            }
            if (inputMap["o"]) {
                index_detekce = 6; index_pole = 0;   console.log("Alg s OBB a per triangle");
                keydown = true;
            }
            if (inputMap["i"]) {
                index_detekce = 7; index_pole = 0;   console.log("Alg s FaceT a per triangle");
                keydown = true;
            }
            if (inputMap["u"]) {
                index_detekce = 8; index_pole = 0;   console.log("Alg s FaceT a nový per triangle");
                keydown = true;
            }
            //xxxxxxxxxxxxxxxx

        for (let x = 0; x < scene.meshes.length; x++) 
        {
            scene.meshes[x].updateFacetData();  
        }
 
        
        var vzdalenost0 = -1;
        var pocet_kolizi = 0;
        let timee = performance.now();  
        
        // dvojitý cyklus pro detekci kolizí mezi všemi dvojicemi objektu
        // autor všeho, co se nachází v tomto dvojitém cyklu: Tomáš Přibyl
        
        for (var prvni_index = 0; prvni_index < scene.meshes.length; prvni_index++) 
        {
        for (var druhy_index = prvni_index+1; druhy_index < scene.meshes.length; druhy_index++) 
        {                                        
        
        if(index_detekce == 0)  //g    algoritmus využívající vestavenou funkci Baylon.js
        {                       //studijní materiály: [1]
            if (scene.meshes[prvni_index].intersectsMesh(scene.meshes[druhy_index], true)) {
                pocet_kolizi = pocet_kolizi+1;
           //     hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
            } 

        }
        else if(index_detekce == 1)   //h    algoritmus s nejvetším rozmerem
        {                              //studijní materiály: [1][5]
            
            var posx = scene.meshes[prvni_index].position.x - scene.meshes[druhy_index].position.x;   // algoritmus získa nejvetší vzdálenost objektu
            var posy = scene.meshes[prvni_index].position.y - scene.meshes[druhy_index].position.y;
            var posz = scene.meshes[prvni_index].position.z - scene.meshes[druhy_index].position.z;
            var vzdalenost = Math.sqrt(posx*posx + posy*posy + posz*posz); 
                 
            var rozmer_herox = scene.meshes[prvni_index].getBoundingInfo().maximum["x"] ;
            var rozmer_heroy = scene.meshes[prvni_index].getBoundingInfo().maximum["y"] ;
            var rozmer_heroz = scene.meshes[prvni_index].getBoundingInfo().maximum["z"] ;
            
            var rozmer_groundx = scene.meshes[druhy_index].getBoundingInfo().maximum["x"];    // algoritmus získa nejvetší rozmer objektu
            var rozmer_groundy = scene.meshes[druhy_index].getBoundingInfo().maximum["y"];
            var rozmer_groundz = scene.meshes[druhy_index].getBoundingInfo().maximum["z"];
            
            var rozmer = Math.sqrt(rozmer_herox*rozmer_herox + rozmer_heroy*rozmer_heroy + rozmer_heroz*rozmer_heroz)+Math.sqrt(rozmer_groundx*rozmer_groundx + rozmer_groundy*rozmer_groundy + rozmer_groundz*rozmer_groundz); 

            if(rozmer >= vzdalenost)     // porovná rozmer a vzdálenost
            {
                pocet_kolizi = pocet_kolizi+1;
           //     hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
            }
            
        }
        else if(index_detekce == 2)    // j       algoritmus  s AABB 
        {                               //studijní materiály: [1][5][6][7]
            var posx = scene.meshes[prvni_index].position.x - scene.meshes[druhy_index].position.x;     // získání vzdáleností
            var posy = scene.meshes[prvni_index].position.y - scene.meshes[druhy_index].position.y;
            var posz = scene.meshes[prvni_index].position.z - scene.meshes[druhy_index].position.z;
            
            if(posx<0){posx = posx*-1}
            if(posy<0){posy = posy*-1}
            if(posz<0){posz = posz*-1}
            
            var rozmer_herox = scene.meshes[prvni_index].getBoundingInfo().maximum["x"] ;        // získání rozmeru
            var rozmer_heroy = scene.meshes[prvni_index].getBoundingInfo().maximum["y"] ;
            var rozmer_heroz = scene.meshes[prvni_index].getBoundingInfo().maximum["z"] ;
            
            var rozmer_groundx = scene.meshes[druhy_index].getBoundingInfo().maximum["x"];
            var rozmer_groundy = scene.meshes[druhy_index].getBoundingInfo().maximum["y"];
            var rozmer_groundz = scene.meshes[druhy_index].getBoundingInfo().maximum["z"];
            
            //xxxxxxxxxxxxxxxxxxxxxxxxxxx
            var euler_ground = scene.meshes[druhy_index].rotationQuaternion.toEulerAngles();       //  rozmer se aktualizuje podle rotace v ose x
            
            var pripona_ground = Math.sqrt(rozmer_groundx*rozmer_groundx  +  rozmer_groundy*rozmer_groundy);
            
            var uhelx_ground = Math.asin(rozmer_groundx/pripona_ground);
            
            rozmer_groundx = pripona_ground * Math.sin(euler_ground.z + uhelx_ground);
            rozmer_groundy = pripona_ground * Math.cos(euler_ground.z + uhelx_ground);
            
            if(rozmer_groundx<0){rozmer_groundx=rozmer_groundx*-1}
            if(rozmer_groundy<0){rozmer_groundy=rozmer_groundy*-1}
            
            //xxxxxxxxxxxxxxxxxxxxxxx
            
            pripona_ground = Math.sqrt(rozmer_groundx*rozmer_groundx  +  rozmer_groundz*rozmer_groundz);       //  rozmer se aktualizuje podle rotace v ose z
            
            var uhelz_ground = Math.asin(rozmer_groundz/pripona_ground);
            
            rozmer_groundz = pripona_ground * Math.sin(euler_ground.y + uhelz_ground);
            rozmer_groundx = pripona_ground * Math.cos(euler_ground.y + uhelz_ground);
            
            if(rozmer_groundx<0){rozmer_groundx=rozmer_groundx*-1}
            if(rozmer_groundz<0){rozmer_groundz=rozmer_groundz*-1}
            
            //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
            
            pripona_ground = Math.sqrt(rozmer_groundz*rozmer_groundz  +  rozmer_groundy*rozmer_groundy);       //  rozmer se aktualizuje podle rotace v ose y
            
            var uhely_ground = Math.asin(rozmer_groundy/pripona_ground);
            
            rozmer_groundy = pripona_ground * Math.sin(euler_ground.x + uhely_ground);
            rozmer_groundz = pripona_ground * Math.cos(euler_ground.x + uhely_ground);
            
            if(rozmer_groundy<0){rozmer_groundy=rozmer_groundy*-1}
            if(rozmer_groundz<0){rozmer_groundz=rozmer_groundz*-1}
            
            //yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
            var euler_hero = scene.meshes[prvni_index].rotationQuaternion.toEulerAngles()              // rozmer se aktualizuje i u druhého objektu
            var pripona_hero = Math.sqrt(rozmer_herox*rozmer_herox  +  rozmer_heroy*rozmer_heroy);
            var uhelx_hero = Math.asin(rozmer_herox/pripona_hero);
            rozmer_herox = pripona_hero * Math.sin(euler_hero.z + uhelx_hero);
            rozmer_heroy = pripona_hero * Math.cos(euler_hero.z + uhelx_hero);
            if(rozmer_herox<0){rozmer_herox=rozmer_herox*-1}
            if(rozmer_heroy<0){rozmer_heroy=rozmer_heroy*-1}
            //yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
            pripona_hero = Math.sqrt(rozmer_herox*rozmer_herox  +  rozmer_heroz*rozmer_heroz);
            var uhelz_hero = Math.asin(rozmer_heroz/pripona_hero);
            rozmer_heroz = pripona_hero * Math.sin(euler_hero.y + uhelz_hero);
            rozmer_herox = pripona_hero * Math.cos(euler_hero.y + uhelz_hero);
            if(rozmer_herox<0){rozmer_herox=rozmer_herox*-1}
            if(rozmer_heroz<0){rozmer_heroz=rozmer_heroz*-1}
            //yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
            pripona_hero = Math.sqrt(rozmer_heroz*rozmer_heroz  +  rozmer_heroy*rozmer_heroy);
            var uhely_hero = Math.asin(rozmer_heroy/pripona_hero);
            rozmer_heroy = pripona_hero * Math.sin(euler_hero.x + uhely_hero);
            rozmer_heroz = pripona_hero * Math.cos(euler_hero.x + uhely_hero);
            if(rozmer_heroy<0){rozmer_heroy=rozmer_heroy*-1}
            if(rozmer_heroz<0){rozmer_heroz=rozmer_heroz*-1} 
            //yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
            
            var rozmerx = rozmer_herox + rozmer_groundx;                              // rozmery a vzdálenosti se porovnají
            var rozmery = rozmer_heroy + rozmer_groundy;
            var rozmerz = rozmer_heroz + rozmer_groundz;
            
            
            if ((posx <= rozmerx && posy <= rozmery && posz <= rozmerz)) 
            {
            //    hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);   
               pocet_kolizi = pocet_kolizi+1;
            }        
        } 
                
        else if(index_detekce == 3)  //k        algoritmus s FaceT a pocítadlem vzdálenosti
        {                                        //studijní materiály: [1]
            let rozmer_groundx = scene.meshes[druhy_index].getBoundingInfo().maximum["x"];     // ziskaji se udaje pro optimalizacni funkci
            let rozmer_groundy = scene.meshes[druhy_index].getBoundingInfo().maximum["y"];     // ktera zjistí zda jsou objekty dostatecne blízko
            let rozmer_groundz = scene.meshes[druhy_index].getBoundingInfo().maximum["z"];                

            let rozloha_ground = (rozmer_groundx*rozmer_groundy + rozmer_groundy*rozmer_groundz + rozmer_groundz*rozmer_groundx)*2;   //rozmery
            var ground_pridani = Math.ceil(scene.meshes[druhy_index].facetNb / (rozloha_ground*10));
            
            let rozmer_herox = scene.meshes[prvni_index].getBoundingInfo().maximum["x"] ;
            let rozmer_heroy = scene.meshes[prvni_index].getBoundingInfo().maximum["y"] ;
            let rozmer_heroz = scene.meshes[prvni_index].getBoundingInfo().maximum["z"] ;
            
            let rozloha_hero = (rozmer_herox*rozmer_heroy + rozmer_heroy*rozmer_heroz + rozmer_heroz*rozmer_herox)*2;   // vzdálenost
            var hero_pridani = Math.ceil(scene.meshes[prvni_index].facetNb / (rozloha_hero*10));
            

         
            if(optimalizacni_funkce(scene.meshes[prvni_index], scene.meshes[druhy_index]) == true)
            {           
            ///////////////
            var dotyk = 0;
            
            for(let x = 0; x < scene.meshes[druhy_index].facetNb; x=x+ground_pridani)            // pokud jsou objekty blízko
            {
                for(let y = 0; y < scene.meshes[prvni_index].facetNb; y=y+hero_pridani)         // tak se na vzdálenost testují FaceT objektu
                {
                    var poshero = scene.meshes[prvni_index].getFacetPosition(y);
                    var posground = scene.meshes[druhy_index].getFacetPosition(x);
                    var dX = poshero["x"] - posground["x"];
                    var dY = poshero["y"] - posground["y"];
                    var dZ = poshero["z"] - posground["z"]; 
                    var vzdalenost = dX * dX + dY * dY + dZ * dZ;
 
                    if(vzdalenost < 0.25)
                    {
                        pocet_kolizi = pocet_kolizi+1;                                        // jakmile je zachytí kolize, vše se ukoncí
                //        hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
                        dotyk = 1;
                        break;
                    }

                }
                if(dotyk == 1){break;}
            }
 
            }
   
        }   
        else if(index_detekce == 4)  //l              algoritmus s OBB
        {                            //studijní materiály: [1][3][5][6][7]
            var indexL1 = prvni_index;
            var indexL2 = druhy_index;
      
            for (let i = 0; i < 2; i++) 
            {

            var rozmer_herox = scene.meshes[indexL1].getBoundingInfo().maximum["x"] ;      // podle rozmeru a poloh
            var rozmer_heroy = scene.meshes[indexL1].getBoundingInfo().maximum["y"] ;
            var rozmer_heroz = scene.meshes[indexL1].getBoundingInfo().maximum["z"] ;      // se urcí 8 pozic rohu telesa, kterým se objekty obalí
            
            var rozmer_groundx = scene.meshes[indexL2].getBoundingInfo().maximum["x"];     // tyto pozice se uloží do pole
            var rozmer_groundy = scene.meshes[indexL2].getBoundingInfo().maximum["y"];
            var rozmer_groundz = scene.meshes[indexL2].getBoundingInfo().maximum["z"];
        
            var hero_hrana0 = [scene.meshes[indexL1].position.x - rozmer_herox, scene.meshes[indexL1].position.y - rozmer_heroy, scene.meshes[indexL1].position.z - rozmer_heroz];
            var hero_hrana1 = [scene.meshes[indexL1].position.x - rozmer_herox, scene.meshes[indexL1].position.y - rozmer_heroy,  scene.meshes[indexL1].position.z + rozmer_heroz];
            var hero_hrana2 = [scene.meshes[indexL1].position.x - rozmer_herox,  scene.meshes[indexL1].position.y + rozmer_heroy, scene.meshes[indexL1].position.z - rozmer_heroz];
            var hero_hrana3 = [scene.meshes[indexL1].position.x - rozmer_herox,  scene.meshes[indexL1].position.y + rozmer_heroy,  scene.meshes[indexL1].position.z + rozmer_heroz];
            var hero_hrana4 = [ scene.meshes[indexL1].position.x + rozmer_herox, scene.meshes[indexL1].position.y - rozmer_heroy, scene.meshes[indexL1].position.z - rozmer_heroz];
            var hero_hrana5 = [ scene.meshes[indexL1].position.x + rozmer_herox, scene.meshes[indexL1].position.y - rozmer_heroy,  scene.meshes[indexL1].position.z + rozmer_heroz];
            var hero_hrana6 = [ scene.meshes[indexL1].position.x + rozmer_herox, scene.meshes[indexL1].position.y + rozmer_heroy, scene.meshes[indexL1].position.z - rozmer_heroz];
            var hero_hrana7 = [ scene.meshes[indexL1].position.x + rozmer_herox, scene.meshes[indexL1].position.y + rozmer_heroy,  scene.meshes[indexL1].position.z + rozmer_heroz];
            var hero_hrany = [hero_hrana0, hero_hrana1, hero_hrana2, hero_hrana3, hero_hrana4, hero_hrana5, hero_hrana6, hero_hrana7];
            
            var ground_hrana0 = [scene.meshes[indexL2].position.x - rozmer_groundx, scene.meshes[indexL2].position.y - rozmer_groundy, scene.meshes[indexL2].position.z - rozmer_groundz];
            var ground_hrana1 = [scene.meshes[indexL2].position.x - rozmer_groundx, scene.meshes[indexL2].position.y - rozmer_groundy,  scene.meshes[indexL2].position.z + rozmer_groundz];
            var ground_hrana2 = [scene.meshes[indexL2].position.x - rozmer_groundx,  scene.meshes[indexL2].position.y + rozmer_groundy, scene.meshes[indexL2].position.z - rozmer_groundz];
            var ground_hrana3 = [scene.meshes[indexL2].position.x - rozmer_groundx,  scene.meshes[indexL2].position.y + rozmer_groundy,  scene.meshes[indexL2].position.z + rozmer_groundz];
            var ground_hrana4 = [ scene.meshes[indexL2].position.x + rozmer_groundx, scene.meshes[indexL2].position.y - rozmer_groundy, scene.meshes[indexL2].position.z - rozmer_groundz];
            var ground_hrana5 = [ scene.meshes[indexL2].position.x + rozmer_groundx, scene.meshes[indexL2].position.y - rozmer_groundy,  scene.meshes[indexL2].position.z + rozmer_groundz];
            var ground_hrana6 = [ scene.meshes[indexL2].position.x + rozmer_groundx, scene.meshes[indexL2].position.y + rozmer_groundy, scene.meshes[indexL2].position.z - rozmer_groundz];
            var ground_hrana7 = [ scene.meshes[indexL2].position.x + rozmer_groundx, scene.meshes[indexL2].position.y + rozmer_groundy,  scene.meshes[indexL2].position.z + rozmer_groundz];
            var ground_hrany = [ground_hrana0, ground_hrana1, ground_hrana2, ground_hrana3, ground_hrana4, ground_hrana5, ground_hrana6, ground_hrana7];

           if(rotace_pro_5_alg(scene.meshes[indexL1], hero_hrany, scene.meshes[indexL2], ground_hrany) == 1)      // toto pole se predá funci rotace_pro_5_alg
           {
            //    hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
                pocet_kolizi = pocet_kolizi+1;
                break;
           } 
           else
           {
                let zaloha_index = indexL1;             // pokud se nezachytí poprvé kolize tak se poradí objektu pro funkci prohodí
                indexL1 = indexL2;
                indexL2 = zaloha_index;
           }           
           
            } 
            
        }
        else if(index_detekce == 5)  //p             algoritmus s FaceT a vektory 
        {                                         //studijní materiály: [1]
            var hero_hrany = [];
            var ground_hrany = [];
            
            for(let x = 0; x < scene.meshes[druhy_index].facetNb; x=x+20)            // do pole se uloží pozice FaceT objektu
            {   
                var posground = scene.meshes[druhy_index].getFacetPosition(x);
                ground_hrany.push([posground["x"], posground["y"], posground["z"]]);
                
            }
            
            for(let y = 0; y < scene.meshes[prvni_index].facetNb; y=y+20)
            {
                var poshero = scene.meshes[prvni_index].getFacetPosition(y);
                hero_hrany.push([poshero["x"], poshero["y"], poshero["z"]]);
            }
            
 
            var dotyk = 0;            
            for(let x = 0; x < hero_hrany.length; x++)
            { 
                let xy_kladny = 0; let xy_zaporny = 0;                // promenné pro uložení informací
                let yz_kladny = 0; let yz_zaporny = 0;  
                let zx_kladny = 0; let zx_zaporny = 0;
                
                let xy_mix12 = 0; let xy_mix21 = 0;  
                let yz_mix12 = 0; let yz_mix21 = 0;  
                let zx_mix12 = 0; let zx_mix21 = 0; 
                 
                let x_vzdalenost = 0;  let y_vzdalenost = 0;  let z_vzdalenost = 0;
                
                for(let y = 0; y < ground_hrany.length; y++)  
                { 
                    let xx = ground_hrany[y][0] - hero_hrany[x][0];       // z pozic FaceT objektu se vytvárí vektory
                    let yy = ground_hrany[y][1] - hero_hrany[x][1];
                    let zz = ground_hrany[y][2] - hero_hrany[x][2];
                    
                    if(xx > 0 && yy > 0){ xy_kladny = 1; }             // a zkoumá se jakými jdou smery
                    if(yy > 0 && zz > 0){ yz_kladny = 1; }             // vektory musí jít 4ruznými smery aby byly objekty v kolizi
                    if(zz > 0 && xx > 0){ zx_kladny = 1; }
                    if(xx < 0 && yy < 0){ xy_zaporny = 1; }
                    if(yy < 0 && zz < 0){ yz_zaporny = 1; }
                    if(zz < 0 && xx < 0){ zx_zaporny = 1; }
                    
                    if(xx > 0 && yy < 0){ xy_mix12 = 1; }
                    if(yy > 0 && zz < 0){ yz_mix12 = 1; }
                    if(zz > 0 && xx < 0){ zx_mix12 = 1; }
                    if(xx < 0 && yy > 0){ xy_mix21 = 1; }
                    if(yy < 0 && zz > 0){ yz_mix21 = 1; }
                    if(zz < 0 && xx > 0){ zx_mix21 = 1; } 
                    
                                        
                    if(xx < 0.2 && xx > -0.2){ x_vzdalenost = 1; }         // poté se zkontroluje už jen vzdálenost v dalším smeru
                    if(yy < 0.2 && yy > -0.2){ y_vzdalenost = 1; }
                    if(zz < 0.2 && zz > -0.2){ z_vzdalenost = 1; }                                                                                
                    
                    if(xy_kladny == 1 && xy_zaporny == 1 && xy_mix12 == 1 && xy_mix21 == 1 && z_vzdalenost == 1)         // jakmile jsou podmínky pro kolizi splneny vše koncí
                    {
                   //     hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);  
                        pocet_kolizi = pocet_kolizi+1;    dotyk = 1;   break;
                    }
                    if(yz_kladny == 1 && yz_zaporny == 1 && yz_mix12 == 1 && yz_mix21 == 1 && x_vzdalenost == 1)    
                    {
                 //      hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0); 
                        pocet_kolizi = pocet_kolizi+1;  dotyk = 1;     break;
                    }
                    if(zx_kladny == 1 && zx_zaporny == 1 && zx_mix12 == 1 && zx_mix21 == 1 && y_vzdalenost == 1)    
                    {
                   //     hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);   
                        pocet_kolizi = pocet_kolizi+1;   dotyk = 1;   break;
                    }    
                       
                }
                if(dotyk == 1)
                {  break;}                
                                                                
            } 
            
            if(dotyk == 0)                    // pokud se kolize nenajde, vše provede znovu, ale tentokrát se vektory pocítají
            {                                 // od druhého objektu k prvnímu
            for(let x = 0; x < ground_hrany.length; x++)
            { 
                let xy_kladny = 0; let xy_zaporny = 0;  
                let yz_kladny = 0; let yz_zaporny = 0;  
                let zx_kladny = 0; let zx_zaporny = 0;
                
                let xy_mix12 = 0; let xy_mix21 = 0;  
                let yz_mix12 = 0; let yz_mix21 = 0;  
                let zx_mix12 = 0; let zx_mix21 = 0; 
                 
                let x_vzdalenost = 0;  let y_vzdalenost = 0;  let z_vzdalenost = 0;
                
                for(let y = 0; y < hero_hrany.length; y++)  
                { 
                    let xx = hero_hrany[y][0] - ground_hrany[x][0];
                    let yy = hero_hrany[y][1] - ground_hrany[x][1];
                    let zz = hero_hrany[y][2] - ground_hrany[x][2];
                    
                    if(xx > 0 && yy > 0){ xy_kladny = 1; }
                    if(yy > 0 && zz > 0){ yz_kladny = 1; }
                    if(zz > 0 && xx > 0){ zx_kladny = 1; }
                    if(xx < 0 && yy < 0){ xy_zaporny = 1; }
                    if(yy < 0 && zz < 0){ yz_zaporny = 1; }
                    if(zz < 0 && xx < 0){ zx_zaporny = 1; }
                    
                    if(xx > 0 && yy < 0){ xy_mix12 = 1; }
                    if(yy > 0 && zz < 0){ yz_mix12 = 1; }
                    if(zz > 0 && xx < 0){ zx_mix12 = 1; }
                    if(xx < 0 && yy > 0){ xy_mix21 = 1; }
                    if(yy < 0 && zz > 0){ yz_mix21 = 1; }
                    if(zz < 0 && xx > 0){ zx_mix21 = 1; } 
                    
                                        
                    if(xx < 0.5 && xx > -0.5){ x_vzdalenost = 1; }
                    if(yy < 0.5 && yy > -0.5){ y_vzdalenost = 1; }
                    if(zz < 0.5 && zz > -0.5){ z_vzdalenost = 1; }                                                                                
                    
                    if(xy_kladny == 1 && xy_zaporny == 1 && xy_mix12 == 1 && xy_mix21 == 1 && z_vzdalenost == 1)
                    {
                    //    hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0); 
                         pocet_kolizi = pocet_kolizi+1;  dotyk = 1;   break;
                    }
                    if(yz_kladny == 1 && yz_zaporny == 1 && yz_mix12 == 1 && yz_mix21 == 1 && x_vzdalenost == 1)    
                    {
                    //    hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0); 
                        pocet_kolizi = pocet_kolizi+1;   dotyk = 1;   break; 
                    }
                    if(zx_kladny == 1 && zx_zaporny == 1 && zx_mix12 == 1 && zx_mix21 == 1 && y_vzdalenost == 1)  
                    {
                    //    hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);  
                         pocet_kolizi = pocet_kolizi+1;   dotyk = 1;   break;
                    }                                                                                                 
                       
                }
                
                if(dotyk == 1)
                {  break;}                                
                
            }   
            }                        
            
        } 
        else if(index_detekce == 6)  //o           algoritmus s OBB a per triangle
        {                                          //studijní materiály: [1][2][3][5][6][7]
            if(optimalizacni_funkce(scene.meshes[prvni_index], scene.meshes[druhy_index]) == true)
            {
            
            var rozmer_herox = scene.meshes[prvni_index].getBoundingInfo().maximum["x"] ;      // pomoci pozice a rozmeru zjisti 
            var rozmer_heroy = scene.meshes[prvni_index].getBoundingInfo().maximum["y"] ;     // pozice rohu obalovacího telesa
            var rozmer_heroz = scene.meshes[prvni_index].getBoundingInfo().maximum["z"] ;     // které obalí objekty
            
            var rozmer_groundx = scene.meshes[druhy_index].getBoundingInfo().maximum["x"];
            var rozmer_groundy = scene.meshes[druhy_index].getBoundingInfo().maximum["y"];
            var rozmer_groundz = scene.meshes[druhy_index].getBoundingInfo().maximum["z"];    // tyto pozice se uloží do polí
        
            var hero_hrana0 = [scene.meshes[prvni_index].position.x - rozmer_herox, scene.meshes[prvni_index].position.y - rozmer_heroy, scene.meshes[prvni_index].position.z - rozmer_heroz];
            var hero_hrana1 = [scene.meshes[prvni_index].position.x - rozmer_herox, scene.meshes[prvni_index].position.y - rozmer_heroy,  scene.meshes[prvni_index].position.z + rozmer_heroz];
            var hero_hrana2 = [scene.meshes[prvni_index].position.x - rozmer_herox,  scene.meshes[prvni_index].position.y + rozmer_heroy, scene.meshes[prvni_index].position.z - rozmer_heroz];
            var hero_hrana3 = [scene.meshes[prvni_index].position.x - rozmer_herox,  scene.meshes[prvni_index].position.y + rozmer_heroy,  scene.meshes[prvni_index].position.z + rozmer_heroz];
            var hero_hrana4 = [ scene.meshes[prvni_index].position.x + rozmer_herox, scene.meshes[prvni_index].position.y - rozmer_heroy, scene.meshes[prvni_index].position.z - rozmer_heroz];
            var hero_hrana5 = [ scene.meshes[prvni_index].position.x + rozmer_herox, scene.meshes[prvni_index].position.y - rozmer_heroy,  scene.meshes[prvni_index].position.z + rozmer_heroz];
            var hero_hrana6 = [ scene.meshes[prvni_index].position.x + rozmer_herox, scene.meshes[prvni_index].position.y + rozmer_heroy, scene.meshes[prvni_index].position.z - rozmer_heroz];
            var hero_hrana7 = [ scene.meshes[prvni_index].position.x + rozmer_herox, scene.meshes[prvni_index].position.y + rozmer_heroy,  scene.meshes[prvni_index].position.z + rozmer_heroz];
            var hero_hrany = [hero_hrana0, hero_hrana1, hero_hrana2, hero_hrana3, hero_hrana4, hero_hrana5, hero_hrana6, hero_hrana7];
            
            var ground_hrana0 = [scene.meshes[druhy_index].position.x - rozmer_groundx, scene.meshes[druhy_index].position.y - rozmer_groundy, scene.meshes[druhy_index].position.z - rozmer_groundz];
            var ground_hrana1 = [scene.meshes[druhy_index].position.x - rozmer_groundx, scene.meshes[druhy_index].position.y - rozmer_groundy,  scene.meshes[druhy_index].position.z + rozmer_groundz];
            var ground_hrana2 = [scene.meshes[druhy_index].position.x - rozmer_groundx,  scene.meshes[druhy_index].position.y + rozmer_groundy, scene.meshes[druhy_index].position.z - rozmer_groundz];
            var ground_hrana3 = [scene.meshes[druhy_index].position.x - rozmer_groundx,  scene.meshes[druhy_index].position.y + rozmer_groundy,  scene.meshes[druhy_index].position.z + rozmer_groundz];
            var ground_hrana4 = [ scene.meshes[druhy_index].position.x + rozmer_groundx, scene.meshes[druhy_index].position.y - rozmer_groundy, scene.meshes[druhy_index].position.z - rozmer_groundz];
            var ground_hrana5 = [ scene.meshes[druhy_index].position.x + rozmer_groundx, scene.meshes[druhy_index].position.y - rozmer_groundy,  scene.meshes[druhy_index].position.z + rozmer_groundz];
            var ground_hrana6 = [ scene.meshes[druhy_index].position.x + rozmer_groundx, scene.meshes[druhy_index].position.y + rozmer_groundy, scene.meshes[druhy_index].position.z - rozmer_groundz];
            var ground_hrana7 = [ scene.meshes[druhy_index].position.x + rozmer_groundx, scene.meshes[druhy_index].position.y + rozmer_groundy,  scene.meshes[druhy_index].position.z + rozmer_groundz];
            var ground_hrany = [ground_hrana0, ground_hrana1, ground_hrana2, ground_hrana3, ground_hrana4, ground_hrana5, ground_hrana6, ground_hrana7];
            

            var euler_ground = scene.meshes[druhy_index].rotationQuaternion.toEulerAngles();        // nyní se zrotují
             
             for (let n=0; n < hero_hrany.length; n++) 
            {
                hero_hrany[n][0] = hero_hrany[n][0] - scene.meshes[prvni_index].position.x;
                hero_hrany[n][1] = hero_hrany[n][1] - scene.meshes[prvni_index].position.y;
                hero_hrany[n][2] = hero_hrany[n][2] - scene.meshes[prvni_index].position.z;
            }
             
            var euler_hero = scene.meshes[prvni_index].rotationQuaternion.toEulerAngles(); 
            
            var hero_sin_x = Math.sin(euler_hero.x);
            var hero_cos_x = Math.cos(euler_hero.x);
    
            for (let n=0; n < hero_hrany.length; n++)                                        // osa x
            {
                let y = hero_hrany[n][1];
                let z = hero_hrany[n][2];
                hero_hrany[n][1] = y * hero_cos_x - z * hero_sin_x;
                hero_hrany[n][2] = z * hero_cos_x + y * hero_sin_x;
            }
            
            var hero_sin_y = Math.sin(euler_hero.y);
            var hero_cos_y = Math.cos(euler_hero.y);
    
            for (let n=0; n < hero_hrany.length; n++)                                    // osa y
            {
                let x = hero_hrany[n][0];
                var z = hero_hrany[n][2];
                hero_hrany[n][0] = x * hero_cos_y + z * hero_sin_y;
                hero_hrany[n][2] = z * hero_cos_y - x * hero_sin_y;
            }
            
            var hero_sin_z = Math.sin(euler_hero.z);
            var hero_cos_z = Math.cos(euler_hero.z);  
    
            for (let n=0; n < hero_hrany.length; n++)                                 // osa z
            {
                let x = hero_hrany[n][0];
                let y = hero_hrany[n][1];
                hero_hrany[n][0] = x * hero_cos_z - y * hero_sin_z;
                hero_hrany[n][1] = y * hero_cos_z + x * hero_sin_z;
            } 
            
            for (let n=0; n < hero_hrany.length; n++) 
            {
                hero_hrany[n][0] = hero_hrany[n][0] + scene.meshes[prvni_index].position.x;
                hero_hrany[n][1] = hero_hrany[n][1] + scene.meshes[prvni_index].position.y;
                hero_hrany[n][2] = hero_hrany[n][2] + scene.meshes[prvni_index].position.z;
            }
             
            for (let n=0; n < ground_hrany.length; n++) 
            {                                                                                               // rotace druhého objektu
                ground_hrany[n][0] = ground_hrany[n][0] - scene.meshes[druhy_index].position.x;
                ground_hrany[n][1] = ground_hrany[n][1] - scene.meshes[druhy_index].position.y;
                ground_hrany[n][2] = ground_hrany[n][2] - scene.meshes[druhy_index].position.z;
            }
            
            var ground_sin_x = Math.sin(euler_ground.x);
            var ground_cos_x = Math.cos(euler_ground.x);
    
            for (let n=0; n < ground_hrany.length; n++)                                                 // osa x
            {
                let y = ground_hrany[n][1];
                let z = ground_hrany[n][2];
                ground_hrany[n][1] = y * ground_cos_x - z * ground_sin_x;
                ground_hrany[n][2] = z * ground_cos_x + y * ground_sin_x;
            }
            
            var ground_sin_y = Math.sin(euler_ground.y);
            var ground_cos_y = Math.cos(euler_ground.y);
    
            for (let n=0; n < ground_hrany.length; n++)                                                         // osa y
            {
                let x = ground_hrany[n][0];
                var z = ground_hrany[n][2];
                ground_hrany[n][0] = x * ground_cos_y + z * ground_sin_y;
                ground_hrany[n][2] = z * ground_cos_y - x * ground_sin_y;
            }
            
            var ground_sin_z = Math.sin(euler_ground.z);
            var ground_cos_z = Math.cos(euler_ground.z);  
    
            for (let n=0; n < ground_hrany.length; n++) 
            {                                                                                        // osa z
                let x = ground_hrany[n][0];
                let y = ground_hrany[n][1];
                ground_hrany[n][0] = x * ground_cos_z - y * ground_sin_z;
                ground_hrany[n][1] = y * ground_cos_z + x * ground_sin_z;
            } 
            
            for (let n=0; n < ground_hrany.length; n++) 
            {
                ground_hrany[n][0] = ground_hrany[n][0] + scene.meshes[druhy_index].position.x;
                ground_hrany[n][1] = ground_hrany[n][1] + scene.meshes[druhy_index].position.y;
                ground_hrany[n][2] = ground_hrany[n][2] + scene.meshes[druhy_index].position.z;
            }
           

           var dotyk = 0;                                              // z 6 sten obalovacího telesa se udelá 12 trojúhelníku
           const seznam_troj = [0,1,2,   1,2,3,     0,1,4,     1,4,5,     2,3,6,     3,6,7,    1,3,7,    1,5,7,    2,4,6,   0,2,4,      4,5,6,    5,6,7,      0,2,7,      0,5,7,          1,3,6,    1,4,6];

           for(let x = 0; x < seznam_troj.length; x=x+3)
            {  
                for(let y = 0; y < seznam_troj.length; y=y+3)  
                {
                    var bod11 = new BABYLON.Vector3(ground_hrany[seznam_troj[x]][0], ground_hrany[seznam_troj[x]][1], ground_hrany[seznam_troj[x]][2]);
                    var bod12 = new BABYLON.Vector3(ground_hrany[seznam_troj[x+1]][0], ground_hrany[seznam_troj[x+1]][1], ground_hrany[seznam_troj[x+1]][2]);
                    var bod13 = new BABYLON.Vector3(ground_hrany[seznam_troj[x+2]][0], ground_hrany[seznam_troj[x+2]][1], ground_hrany[seznam_troj[x+2]][2]);
    
                    var bod21 = new BABYLON.Vector3(hero_hrany[seznam_troj[y]][0], hero_hrany[seznam_troj[y]][1], hero_hrany[seznam_troj[y]][2]);
                    var bod22 = new BABYLON.Vector3(hero_hrany[seznam_troj[y+1]][0], hero_hrany[seznam_troj[y+1]][1], hero_hrany[seznam_troj[y+1]][2]);
                    var bod23 = new BABYLON.Vector3(hero_hrany[seznam_troj[y+2]][0], hero_hrany[seznam_troj[y+2]][1], hero_hrany[seznam_troj[y+2]][2]);
    
                    var trojuhelnik1 = [bod11, bod12, bod13];
                    var trojuhelnik2 = [bod21, bod22, bod23];
    
                    if(doTrianglesIntersect(trojuhelnik1, trojuhelnik2) == true)          // tyto trojúhelníky se poté testují na kolizi
                    {
                    //   hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0); 
                         pocet_kolizi = pocet_kolizi+1;  dotyk = 1;   break;
                    }                
                }
                if(dotyk == 1){break;}
            }
            if(dotyk == 0)
            {
            for(let x = 0; x < ground_hrany.length; x++)
            {  
                for(let y = 0; y < hero_hrany.length; y++)  
                {
                    var bod11 = new BABYLON.Vector3(ground_hrany[x][0], ground_hrany[x][1], ground_hrany[x][2]);
                    var bod12 = new BABYLON.Vector3(ground_hrany[(x+1) % ground_hrany.length][0], ground_hrany[(x+1) % ground_hrany.length][1], ground_hrany[(x+1) % ground_hrany.length][2]);
                    var bod13 = new BABYLON.Vector3(ground_hrany[(x+2) % ground_hrany.length][0], ground_hrany[(x+2) % ground_hrany.length][1], ground_hrany[(x+2) % ground_hrany.length][2]);
    
                    var bod21 = new BABYLON.Vector3(hero_hrany[y][0], hero_hrany[y][1], hero_hrany[y][2]);
                    var bod22 = new BABYLON.Vector3(hero_hrany[(y+1) % hero_hrany.length][0], hero_hrany[(y+1) % hero_hrany.length][1], hero_hrany[(y+1) % hero_hrany.length][2]);
                    var bod23 = new BABYLON.Vector3(hero_hrany[(y+2) % hero_hrany.length][0], hero_hrany[(y+2) % hero_hrany.length][1], hero_hrany[(y+2) % hero_hrany.length][2]);
    
                    var trojuhelnik1 = [bod11, bod12, bod13];
                    var trojuhelnik2 = [bod21, bod22, bod23];
    
                    if(doTrianglesIntersect(trojuhelnik1, trojuhelnik2) == true)       // další testy pro jistotu
                    {
                       //   hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0); 
                          pocet_kolizi = pocet_kolizi+1;   dotyk = 1;   break;
                    }                
                }
                if(dotyk == 1){break;}
            }
            }
            
            } 
            
        }
        else if(index_detekce == 7)  //i                 algoritmus s FaceT a per triangle
        {                                           //studijní materiály: [1][2]
            if(optimalizacni_funkce(scene.meshes[prvni_index], scene.meshes[druhy_index]) == true)     // nejdrive se zkontroluje zda jsou objekty
            {                                                        // dost blízko na to aby vubec byly v kolizi
        
            var hero_hrany = [];
            var ground_hrany = [];
            
            for(let x = 0; x < scene.meshes[druhy_index].facetNb; x=x+25)
            {   
                var posground = scene.meshes[druhy_index].getFacetPosition(x);   
                
                let xDist = scene.meshes[druhy_index].position.x - posground["x"];         // zíkají se uloží do pole pozice FaceT
                let yDist = scene.meshes[druhy_index].position.y - posground["y"];
                let zDist = scene.meshes[druhy_index].position.z - posground["z"];
                let dist = Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist);
                let fractionOfTotal = 1 / dist;
                posground["x"] = posground["x"] - xDist * fractionOfTotal;
                posground["y"] = posground["y"] - yDist * fractionOfTotal;
                posground["z"] = posground["z"] - zDist * fractionOfTotal;  
                
                ground_hrany.push([posground["x"], posground["y"], posground["z"]]);
                
            }
            
            for(let y = 0; y < scene.meshes[prvni_index].facetNb; y=y+25)               // zíkají se uloží do pole pozice FaceT druhého objektu
            {
                var poshero = scene.meshes[prvni_index].getFacetPosition(y); 
                
                let xDist = scene.meshes[prvni_index].position.x - poshero["x"];
                let yDist = scene.meshes[prvni_index].position.y - poshero["y"];
                let zDist = scene.meshes[prvni_index].position.z - poshero["z"];
                let dist = Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist);
                let fractionOfTotal = 1 / dist;
                poshero["x"] = poshero["x"] - xDist * fractionOfTotal;
                poshero["y"] = poshero["y"] - yDist * fractionOfTotal;
                poshero["z"] = poshero["z"] - zDist * fractionOfTotal;    
                
                hero_hrany.push([poshero["x"], poshero["y"], poshero["z"]]);
            }
            
 
            var dotyk = 0;   
             //2 fory s odlisnym pridavanim
            for(let x = 0; x < ground_hrany.length; x++)
            {  
                for(let y = 0; y < hero_hrany.length; y++)    // z pozic FaceT se vybere trojice bodu, udelají se z nich trojúhelníky
                {                                            // a ty se poté otestují na kolizi
                    var bod11 = new BABYLON.Vector3(ground_hrany[x][0], ground_hrany[x][1], ground_hrany[x][2]);
                    var bod12 = new BABYLON.Vector3(ground_hrany[(x+1) % ground_hrany.length][0], ground_hrany[(x+1) % ground_hrany.length][1], ground_hrany[(x+1) % ground_hrany.length][2]);
                    var bod13 = new BABYLON.Vector3(ground_hrany[(x+2) % ground_hrany.length][0], ground_hrany[(x+2) % ground_hrany.length][1], ground_hrany[(x+2) % ground_hrany.length][2]);
    
                    var bod21 = new BABYLON.Vector3(hero_hrany[y][0], hero_hrany[y][1], hero_hrany[y][2]);
                    var bod22 = new BABYLON.Vector3(hero_hrany[(y+1) % hero_hrany.length][0], hero_hrany[(y+1) % hero_hrany.length][1], hero_hrany[(y+1) % hero_hrany.length][2]);
                    var bod23 = new BABYLON.Vector3(hero_hrany[(y+2) % hero_hrany.length][0], hero_hrany[(y+2) % hero_hrany.length][1], hero_hrany[(y+2) % hero_hrany.length][2]);
    
                    var trojuhelnik1 = [bod11, bod12, bod13];
                    var trojuhelnik2 = [bod21, bod22, bod23];
    
                    if(doTrianglesIntersect(trojuhelnik1, trojuhelnik2) == true)      // pokud jsou v kolizi trojúhelníky, tak jsou i objekty
                    {
                    //    hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);  
                         pocet_kolizi = pocet_kolizi+1;   dotyk = 1;   break;
                    }                
                }
                if(dotyk == 1){break;}
            } 
            if(dotyk == 0)
            {   
            for(let x = 0; x < ground_hrany.length; x++)
            {  
                for(let y = 0; y < hero_hrany.length; y++)  
                {
                    var bod11 = new BABYLON.Vector3(ground_hrany[x][0], ground_hrany[x][1], ground_hrany[x][2]);
                    var bod12 = new BABYLON.Vector3(ground_hrany[(x+2) % ground_hrany.length][0], ground_hrany[(x+2) % ground_hrany.length][1], ground_hrany[(x+2) % ground_hrany.length][2]);
                    var bod13 = new BABYLON.Vector3(ground_hrany[(x+4) % ground_hrany.length][0], ground_hrany[(x+4) % ground_hrany.length][1], ground_hrany[(x+4) % ground_hrany.length][2]);
    
                    var bod21 = new BABYLON.Vector3(hero_hrany[y][0], hero_hrany[y][1], hero_hrany[y][2]);
                    var bod22 = new BABYLON.Vector3(hero_hrany[(y+2) % hero_hrany.length][0], hero_hrany[(y+2) % hero_hrany.length][1], hero_hrany[(y+2) % hero_hrany.length][2]);
                    var bod23 = new BABYLON.Vector3(hero_hrany[(y+4) % hero_hrany.length][0], hero_hrany[(y+4) % hero_hrany.length][1], hero_hrany[(y+4) % hero_hrany.length][2]);
    
                    var trojuhelnik1 = [bod11, bod12, bod13];
                    var trojuhelnik2 = [bod21, bod22, bod23];
    
                    if(doTrianglesIntersect(trojuhelnik1, trojuhelnik2) == true)
                    {
                    //    hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);  
                       pocet_kolizi = pocet_kolizi+1;  dotyk = 1;   break;
                    }                
                }
                if(dotyk == 1){break;}
            }
            
            }       
                                   
            } 
        } 
        
        else if(index_detekce == 8)  //u            algoritmus s FaceT a nový per triangle
        {                                           //studijní materiály: [1][2][6][7]
            if(optimalizacni_funkce(scene.meshes[prvni_index], scene.meshes[druhy_index]) == true)   // nejdrive se zkontroluje zda jsou objekty
            {                                                       // dost blízko na to aby vubec byly v kolizi
        
            var hero_hrany = [];
            var ground_hrany = [];
            
            for(let x = 0; x < scene.meshes[druhy_index].facetNb; x=x+25)
            {   
                var posground = scene.meshes[druhy_index].getFacetPosition(x);
                
                let xDist = scene.meshes[druhy_index].position.x - posground["x"];         // zíkají se uloží do pole pozice FaceT
                let yDist = scene.meshes[druhy_index].position.y - posground["y"];
                let zDist = scene.meshes[druhy_index].position.z - posground["z"];
                let dist = Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist);
                let fractionOfTotal = 1 / dist;
                posground["x"] = posground["x"] - xDist * fractionOfTotal;
                posground["y"] = posground["y"] - yDist * fractionOfTotal;
                posground["z"] = posground["z"] - zDist * fractionOfTotal;
                
                ground_hrany.push([posground["x"], posground["y"], posground["z"]]);
                
            }
            
            for(let y = 0; y < scene.meshes[prvni_index].facetNb; y=y+25)              // zíkají se uloží do pole pozice FaceT druhého objektu
            {
                var poshero = scene.meshes[prvni_index].getFacetPosition(y);
                
                let xDist = scene.meshes[prvni_index].position.x - poshero["x"];
                let yDist = scene.meshes[prvni_index].position.y - poshero["y"];
                let zDist = scene.meshes[prvni_index].position.z - poshero["z"];
                let dist = Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist);
                let fractionOfTotal = 1 / dist;
                poshero["x"] = poshero["x"] - xDist * fractionOfTotal;
                poshero["y"] = poshero["y"] - yDist * fractionOfTotal;
                poshero["z"] = poshero["z"] - zDist * fractionOfTotal;
                
                hero_hrany.push([poshero["x"], poshero["y"], poshero["z"]]);
            }
            
 
            var dotyk = 0;   
             //2 fory s odlisnym pridavanim
            for(let x = 0; x < ground_hrany.length; x++)
            {  
                for(let y = 0; y < hero_hrany.length; y++)   // z pozic FaceT se vybere trojice bodu, udelají se z nich trojúhelníky
                {                                            // a ty se poté otestují na kolizi
                    var bod11 = new BABYLON.Vector3(ground_hrany[x][0], ground_hrany[x][1], ground_hrany[x][2]);
                    var bod12 = new BABYLON.Vector3(ground_hrany[(x+1) % ground_hrany.length][0], ground_hrany[(x+1) % ground_hrany.length][1], ground_hrany[(x+1) % ground_hrany.length][2]);
                    var bod13 = new BABYLON.Vector3(ground_hrany[(x+2) % ground_hrany.length][0], ground_hrany[(x+2) % ground_hrany.length][1], ground_hrany[(x+2) % ground_hrany.length][2]);
    
                    var bod21 = new BABYLON.Vector3(hero_hrany[y][0], hero_hrany[y][1], hero_hrany[y][2]);
                    var bod22 = new BABYLON.Vector3(hero_hrany[(y+1) % hero_hrany.length][0], hero_hrany[(y+1) % hero_hrany.length][1], hero_hrany[(y+1) % hero_hrany.length][2]);
                    var bod23 = new BABYLON.Vector3(hero_hrany[(y+2) % hero_hrany.length][0], hero_hrany[(y+2) % hero_hrany.length][1], hero_hrany[(y+2) % hero_hrany.length][2]);
    
                    var trojuhelnik1 = [bod11, bod12, bod13];
                    var trojuhelnik2 = [bod21, bod22, bod23];
    
                    if(doTrianglesIntersect2(trojuhelnik1, trojuhelnik2) == true)     // pokud jsou v kolizi trojúhelníky, tak jsou i objekty 
                    {
                         //    hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);  
                       pocet_kolizi = pocet_kolizi+1;  dotyk = 1;   break;
                    }                
                }
                if(dotyk == 1){break;}
            } 
            if(dotyk == 0)
            {   
            for(let x = 0; x < ground_hrany.length; x++)
            {  
                for(let y = 0; y < hero_hrany.length; y++)  
                {
                    var bod11 = new BABYLON.Vector3(ground_hrany[x][0], ground_hrany[x][1], ground_hrany[x][2]);
                    var bod12 = new BABYLON.Vector3(ground_hrany[(x+2) % ground_hrany.length][0], ground_hrany[(x+2) % ground_hrany.length][1], ground_hrany[(x+2) % ground_hrany.length][2]);
                    var bod13 = new BABYLON.Vector3(ground_hrany[(x+4) % ground_hrany.length][0], ground_hrany[(x+4) % ground_hrany.length][1], ground_hrany[(x+4) % ground_hrany.length][2]);
    
                    var bod21 = new BABYLON.Vector3(hero_hrany[y][0], hero_hrany[y][1], hero_hrany[y][2]);
                    var bod22 = new BABYLON.Vector3(hero_hrany[(y+2) % hero_hrany.length][0], hero_hrany[(y+2) % hero_hrany.length][1], hero_hrany[(y+2) % hero_hrany.length][2]);
                    var bod23 = new BABYLON.Vector3(hero_hrany[(y+4) % hero_hrany.length][0], hero_hrany[(y+4) % hero_hrany.length][1], hero_hrany[(y+4) % hero_hrany.length][2]);
    
                    var trojuhelnik1 = [bod11, bod12, bod13];
                    var trojuhelnik2 = [bod21, bod22, bod23];
    
                    if(doTrianglesIntersect2(trojuhelnik1, trojuhelnik2) == true)          // pro jistotu se vše udelá znovu
                    {
                         //    hero.material.emissiveColor = new BABYLON.Color3(1, 0, 0);  
                       pocet_kolizi = pocet_kolizi+1;  dotyk = 1;   break;
                    }                
                }
                if(dotyk == 1){break;}
            }
            
            }
                   
                                   
            } 
        }
        
        }}                
        
        let timeee1 = performance.now();        // zápis a výpis casu a poctu kolizí
    
        if(index_pole < max_pole )
        { 
            koliz_cas_pole[index_pole]= (timeee1-timee) + "\n";
            pocet_kolizi_pole[index_pole]= pocet_kolizi + "\n";
            pocet_meshu[index_pole]= scene.meshes.length + "\n";
            index_pole = index_pole+1;
        }
        else
        {
            console.log(koliz_cas_pole +"cas");
            console.log(pocet_kolizi_pole +"pocet kolizi");
            console.log(pocet_meshu +"pocet meshu");
            index_pole = 0;
        } 

        });  
        
 
    
    for (let x = 0; x < scene.meshes.length; x++)      // pocet FaceT se zvetší pro objekty
    {                                                  // které mají FaceT nedostatek
        
        let rozmer_groundx = scene.meshes[x].getBoundingInfo().maximum["x"];     // a to podle plochy
        let rozmer_groundy = scene.meshes[x].getBoundingInfo().maximum["y"];
        let rozmer_groundz = scene.meshes[x].getBoundingInfo().maximum["z"];                

        let rozloha = (rozmer_groundx*rozmer_groundy + rozmer_groundy*rozmer_groundz + rozmer_groundz*rozmer_groundx)*2;
        var pocetface = scene.meshes[x].getIndices();
        pocetface = pocetface.length/3;


        while(rozloha*8 > pocetface)
        {     
            scene.meshes[x].increaseFacets(1);
            pocetface = scene.meshes[x].getIndices();
            pocetface = pocetface.length/3;      
        } 
    
    }            
    // vytvárení koulí uvnitr kostky, kterým se priradí náhodná pozice i rotace
    let ball = BABYLON.MeshBuilder.CreateSphere("ball", {diameter: 1, segments: 4}, scene);
    let sign = Math.random() < 0.5;
        ball.position.y = Math.random() * (sign ? -11.2 : -1);
        sign = Math.random() < 0.5;
        ball.position.x = Math.random() * (sign ? 1 : -1)*5.2;
        sign = Math.random() < 0.5;
        ball.position.z = Math.random() * (sign ? 1 : -1)*5.2;
        ball.rotation = new BABYLON.Vector3(Math.random() *360 * Math.PI / 180, Math.random() *360 * Math.PI / 180, Math.random() *360 * Math.PI / 180);    //    ground.rotation.x = 180 * Math.PI / 180 ;
        
    let balls = [ball];
     
    let cannon = true;
    let forceFactor = cannon ? 1 : 1500; 
     
    // aplikace fyzikálního enginu
      var gravityVector = new BABYLON.Vector3(0, 0, 0);
    var physicsPlugin = new BABYLON.CannonJSPlugin(); 
    scene.enablePhysics(gravityVector, physicsPlugin);
     scene.broadphase = new CANNON.GridBroadphase(scene); 
     // aplikace fyziky na objekty
    hero.physicsImpostor = new BABYLON.PhysicsImpostor(hero, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0 }, scene);
    
     
      
 balls.forEach(ball => {
        ball.physicsImpostor = new BABYLON.PhysicsImpostor(ball, BABYLON.PhysicsImpostor.SphereImpostor, {mass: 1});
    });
    
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);
    ground1.physicsImpostor = new BABYLON.PhysicsImpostor(ground1, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);
    ground2.physicsImpostor = new BABYLON.PhysicsImpostor(ground2, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);
    ground3.physicsImpostor = new BABYLON.PhysicsImpostor(ground3, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);
    ground4.physicsImpostor = new BABYLON.PhysicsImpostor(ground4, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);
    ground5.physicsImpostor = new BABYLON.PhysicsImpostor(ground5, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);
      
    // vytvorení slideru pro generování koulí v kostce
    
    let index_zvetseni = 0;
  
    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    var panel = new BABYLON.GUI.StackPanel();
    panel.width = "220px";
    panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
    panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
    advancedTexture.addControl(panel);
    
    header1 = new BABYLON.GUI.TextBlock();
    header1.text = "Pocet kouli: 0";
    header1.height = "30px";
    header1.color = "white";
    panel.addControl(header1);   
    
    var slider = new BABYLON.GUI.Slider();
    slider.minimum = 0;
    slider.maximum = 100;
    slider.value = 0;
    slider.height = "20px";
    slider.width = "200px";
    slider.onValueChangedObservable.add(function(value) {
        header1.text = "Pocet kouli: " + balls.length ;
        
            for(let i=0; i < 2; i++ )
     {
        let mic = BABYLON.MeshBuilder.CreateSphere("ball", {diameter: 1, segments: 4}, scene);  
        let sign = Math.random() < 0.5;
        mic.position.y = Math.random() * (sign ? -11.2 : -1);
        sign = Math.random() < 0.5;
        mic.position.x = Math.random() * (sign ? 1 : -1)*5.2;
        sign = Math.random() < 0.5;
        mic.position.z = Math.random() * (sign ? 1 : -1)*5.2;
        mic.rotation = new BABYLON.Vector3(Math.random() *360 * Math.PI / 180, Math.random() *360 * Math.PI / 180, Math.random() *360 * Math.PI / 180);    //    ground.rotation.x = 180 * Math.PI / 180 ;
        balls.push(mic);  
     } 
     // aplikace fyziky na nove vytvorené koule
     balls.forEach(ball => {
        ball.physicsImpostor = new BABYLON.PhysicsImpostor(ball, BABYLON.PhysicsImpostor.SphereImpostor, {mass: 1});
    });
        
    });
    panel.addControl(slider);  
    
 
    return scene;
};

          /*  ****************************************************
       druha cast kodu prevzateho ze stranek doc.babylonjs.com, ktery zacina na zacatku souboru 
       a funguje jako Hello world aplikace       
        */     

                var scene = createScene(); 

            engine.runRenderLoop(function () { 
                    scene.render();
            });


            window.addEventListener("resize", function () { 
                    engine.resize();
            });
        // konec prevzate casti     
            
    </script>

   </body>

</html>


